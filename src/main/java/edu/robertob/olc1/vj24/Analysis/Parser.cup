package edu.robertob.olc1.vj24.Analysis;


import java_cup.runtime.Symbol;
import java.util.LinkedList;
import edu.robertob.olc1.vj24.Engine.Base.Instruction;
import edu.robertob.olc1.vj24.Engine.Structs.Types;
import edu.robertob.olc1.vj24.Engine.Structs.JCError;

import edu.robertob.olc1.vj24.Engine.Statements.Print;
import edu.robertob.olc1.vj24.Engine.Statements.Declaration;
import edu.robertob.olc1.vj24.Engine.Statements.SymbolAssignation;
import edu.robertob.olc1.vj24.Engine.Expressions.SymbolAccess;

import edu.robertob.olc1.vj24.Engine.Expressions.Primitive;
import edu.robertob.olc1.vj24.Engine.Statements.IfStatement;

import edu.robertob.olc1.vj24.Engine.Expressions.Arithmetic;
import edu.robertob.olc1.vj24.Engine.Expressions.Comparison;
import edu.robertob.olc1.vj24.Engine.Structs.ComparisonOperands;
import edu.robertob.olc1.vj24.Engine.Expressions.Logical;
import edu.robertob.olc1.vj24.Engine.Structs.LogicalOperands;

import edu.robertob.olc1.vj24.Engine.Structs.ArithmeticOperands;

parser code
{:
    JCLexer s;
    Parser(JCLexer s){this.s = s;}

//    public LinkedList<Errores> listaErrores = new LinkedList<>();
    private LinkedList<JCError> errorList = new LinkedList<>();
    public LinkedList<JCError> getSyntaxErrorList(){
        return errorList;
    }

    public void syntax_error(Symbol s){
        errorList.add(new JCError("Sintaxis", "Error en la instruccion, componente: "+s.value, s.left, s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        errorList.add(new JCError("Sintaxis - FATAL", "Error en la instruccion, componente: "+s.value, s.left, s.right));
    }

:}

action code
{:
:}

terminal UNIT_MINUS;
terminal String STRING, ID, INTEGER, DECIMAL, CHAR;
terminal ENDLINE, PLUS, MINUS, EQUALS, OPENBRACE, CLOSEBRACE, ASTERISK, SLASH, MODULO, DOUBLEASTERISK, NEGATION, COLON;
terminal DOUBLEEQUALS, LESS, GREATER, LESSEQUAL, GREATEREQUAL, NOT_EQUALS;
terminal OPENPAR, CLOSEPAR;
terminal RW_PRINT, RW_INT, RW_DOUBLE, RW_STRING, RW_IF, RW_TRUE, RW_FALSE, RW_BOOL, RW_CHAR;
terminal RW_CONST, RW_VAR;
terminal OR, AND, XOR;

//no terminales
nonterminal LinkedList<Instruction> START, STATEMENTS;
nonterminal Instruction STATEMENT;
nonterminal Instruction IMPRESION, DECLARATION, ASSIGNATION;
nonterminal Instruction IF_STMT;
nonterminal Types TYPES;
nonterminal Instruction EXPRESION;

precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NEGATION;
precedence left DOUBLEEQUALS, LESS, GREATER, LESSEQUAL, GREATEREQUAL, NOT_EQUALS;
precedence left PLUS, MINUS;
precedence left ASTERISK, SLASH, MODULO;
precedence nonassoc DOUBLEASTERISK;
precedence right UNIT_MINUS;

start with START;

START ::= STATEMENTS:a      {:   RESULT = a;   :}
;

STATEMENTS ::= STATEMENTS:a STATEMENT:b     {: RESULT = a; RESULT.add(b); :}
                | STATEMENT:a                   {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

STATEMENT ::= IMPRESION: a        {:   RESULT=a;   :}
                | DECLARATION:a       {:   RESULT=a;   :}
                | ASSIGNATION:a        {:   RESULT=a;   :}
                | IF_STMT:a               {:   RESULT=a;   :}
                | error:e ENDLINE       {:   System.out.println(e);   :}
;

IMPRESION ::= RW_PRINT OPENPAR EXPRESION:a CLOSEPAR ENDLINE      {:   RESULT = new Print(a, aleft, aright);   :}
;


DECLARATION ::= RW_CONST ID:a COLON TYPES:b EQUALS EXPRESION:c ENDLINE    {:   RESULT = new Declaration(a, b, c, true, aleft, aright);   :}
              | RW_CONST ID:a COLON TYPES:b ENDLINE    {:   RESULT = new Declaration(a, b, null, true,aleft, aright);   :}
              | RW_VAR ID:a COLON TYPES:b ENDLINE    {:   RESULT = new Declaration(a, b, null, false, aleft, aright);   :}
              | RW_VAR ID:a COLON TYPES:b EQUALS EXPRESION:c ENDLINE    {:   RESULT = new Declaration(a, b, c, false, aleft, aright);   :}
              ;

ASSIGNATION ::= ID:a EQUALS EXPRESION:b ENDLINE  {:   RESULT=new SymbolAssignation(a, b, aleft, aright);  :}
            ;

IF_STMT ::= RW_IF OPENPAR EXPRESION:a CLOSEPAR OPENBRACE STATEMENTS:b CLOSEBRACE {:   RESULT = new IfStatement(a, b, aleft, aright);   :}
        ;

TYPES ::= RW_INT       {:   RESULT=Types.INTEGER;   :}
        | RW_DOUBLE    {:   RESULT=Types.DOUBLE;   :}
        | RW_STRING    {:   RESULT=Types.STRING;   :}
        | RW_BOOL      {:   RESULT=Types.BOOLEAN;   :}
        | RW_CHAR      {:   RESULT=Types.CHARACTER;   :};

EXPRESION ::= MINUS EXPRESION:a             {:   RESULT = new Arithmetic(a, ArithmeticOperands.NEG, aleft, aright);   :} %prec UNIT_MINUS
            | EXPRESION:a ASTERISK EXPRESION:b{:   RESULT = new Arithmetic(a, b, ArithmeticOperands.MUL, aleft, aright);   :}
            | EXPRESION:a SLASH EXPRESION:b   {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.DIV, aleft, aright);   :}
            | EXPRESION:a DOUBLEASTERISK EXPRESION:b{:   RESULT = new Arithmetic(a, b, ArithmeticOperands.POW, aleft, aright);   :}
            | EXPRESION:a MODULO EXPRESION:b  {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.MOD, aleft, aright);   :}
            | EXPRESION:a MINUS EXPRESION:b  {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.SUB, aleft, aright);   :}
            | EXPRESION:a PLUS EXPRESION:b   {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.SUM, aleft, aright);   :}
            | EXPRESION:a DOUBLEEQUALS EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.EQUALS, aleft, aright);    :} %prec DOUBLEEQUALS
            | EXPRESION:a NOT_EQUALS EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.NOT_EQUALS, aleft, aright);    :}
            | EXPRESION:a LESS EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.LESS_THAN, aleft, aright);    :} %prec LESS
            | EXPRESION:a LESSEQUAL EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.LESS_THAN_OR_EQUALS, aleft, aright);    :} %prec LESSEQUAL
            | EXPRESION:a GREATER EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.GREATER_THAN, aleft, aright);    :} %prec GREATER
            | EXPRESION:a GREATEREQUAL EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.GREATER_THAN_OR_EQUALS, aleft, aright);    :} %prec GREATEREQUAL
            | NEGATION EXPRESION:a {:    RESULT = new Logical(a, LogicalOperands.NOT, aleft, aright);    :} %prec NEGATION
            | EXPRESION:a OR EXPRESION:b {:    RESULT = new Logical(a, b, LogicalOperands.OR, aleft, aright);    :}%prec OR
            | EXPRESION:a AND EXPRESION:b {:    RESULT = new Logical(a, b, LogicalOperands.AND, aleft, aright);    :}%prec AND
            | EXPRESION:a XOR EXPRESION:b {:    RESULT = new Logical(a, b, LogicalOperands.XOR, aleft, aright);    :}%prec XOR
            | INTEGER:a      {:   RESULT = new Primitive(Types.INTEGER,Integer.parseInt(a),  aleft, aright );   :}
            | DECIMAL:a     {:   RESULT = new Primitive(Types.DOUBLE,new Double(a),  aleft, aright );   :}
            | STRING:a      {:   RESULT = new Primitive( Types.STRING,a, aleft, aright );   :}
            | CHAR:a        {:   RESULT = new Primitive(Types.CHARACTER, a.charAt(0), aleft, aright );   :}
            | RW_TRUE:a     {:   RESULT = new Primitive(Types.BOOLEAN, true, aleft, aright );   :}
            | RW_FALSE:a    {:   RESULT = new Primitive(Types.BOOLEAN, false, aleft, aright );   :}
            | ID:a          {:   RESULT = new SymbolAccess(a, aleft, aright);   :}
            | OPENPAR EXPRESION:a CLOSEPAR     {:   RESULT = a;   :}
;