package edu.robertob.olc1.vj24.Analysis;

//importaciones
import java_cup.runtime.Symbol;
import java.util.LinkedList;
//import abstracto.Instruccion;
import edu.robertob.olc1.vj24.Engine.Base.Instruction;
import edu.robertob.olc1.vj24.Engine.Structs.Types;
import edu.robertob.olc1.vj24.Engine.Structs.JCError;
//import simbolo.Tipo;
//import simbolo.tipoDato;
//import excepciones.Errores;
//
////instrucciones
//import instrucciones.Print;
import edu.robertob.olc1.vj24.Engine.Statements.Print;
//import instrucciones.Declaracion;
//import instrucciones.AsignacionVar;
//import instrucciones.If;
//
////expresiones
//import expresiones.Nativo;
import edu.robertob.olc1.vj24.Engine.Expressions.Primitive;
//import expresiones.Aritmeticas;
import edu.robertob.olc1.vj24.Engine.Expressions.Arithmetic;
//import expresiones.OperadoresAritmeticos;
import edu.robertob.olc1.vj24.Engine.Structs.ArithmeticOperands;
//import expresiones.Relacionales;
//import expresiones.OperadoresRelacionales;
//import expresiones.AccesoVar;

// parser
parser code
{:
    JCLexer s;
    Parser(JCLexer s){this.s = s;}

//    public LinkedList<Errores> listaErrores = new LinkedList<>();

    public void syntax_error(Symbol s){
//        listaErrores.add(new Errores("SINTACTICO RECUPERABLE",
//                        "No se esperaba el componente "+s.value,
//                        s.left,
//                        s.right));
System.out.println("Error sintactico recuperable"+ s.value);
    }

    public void unrecovered_syntax_error (Symbol s){
//        listaErrores.add(new Errores("SINTACTICO NO RECUPERABLE",
//                        "No se esperaba el componente "+s.value,
//                        s.left,
//                        s.right));
System.out.println("Error sintactico no recuperable"+ s.value);
    }

:}

action code
{:
:}

//terminales
//terminal String CADENA, ENTERO, DECIMAL, ID;
//terminal FINCADENA, IMPRIMIR, INT, DOUBLE, STRING;
//terminal PAR1, PAR2, MAS, MENOS, UMENOS;
//terminal IGUAL, EQUALS;
//terminal TRUE, FALSE, IF, BOOL;
//terminal LLAVE1, LLAVE2;
terminal UNIT_MINUS;
terminal String STRING, ID, INTEGER, DECIMAL, CHAR;
terminal ENDLINE, PLUS, MINUS, EQUALS, OPENBRACE, CLOSEBRACE, ASTERISK, SLASH, MODULO, DOUBLEASTERISK;
terminal OPENPAR, CLOSEPAR;
terminal RW_PRINT, RW_INT, RW_DOUBLE, RW_STRING, RW_IF, RW_TRUE, RW_FALSE, RW_BOOL;

//no terminales
nonterminal LinkedList<Instruction> INICIO, INSTRUCCIONES;
nonterminal Instruction INSTRUCCION;
nonterminal Instruction IMPRESION, DECLARACION, ASIGNACION;
//nonterminal Instruccion SIF;
//nonterminal Tipo TIPOS;
nonterminal Instruction EXPRESION;

//precedence left EQUALS;
precedence left PLUS, MINUS;
precedence left ASTERISK, SLASH, MODULO;
precedence nonassoc DOUBLEASTERISK;
precedence right UNIT_MINUS;

start with INICIO;

INICIO ::= INSTRUCCIONES:a      {:   RESULT = a;   :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b     {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                   {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

INSTRUCCION ::= IMPRESION: a        {:   RESULT=a;   :}
//              | DECLARACION:a       {:   RESULT=a;   :}
//              | ASIGNACION:a        {:   RESULT=a;   :}
//              | SIF:a               {:   RESULT=a;   :}
              | error ENDLINE
;

IMPRESION ::= RW_PRINT OPENPAR EXPRESION:a CLOSEPAR ENDLINE      {:   RESULT = new Print(a, aleft, aright);   :}
;

//DECLARACION ::= TIPOS:a ID:b IGUAL EXPRESION:c FINCADENA    {:   RESULT = new Declaracion(b, c, a, aleft, aright);   :}
//;
//
//ASIGNACION ::= ID:a IGUAL EXPRESION:b FINCADENA  {:   RESULT=new AsignacionVar(a, b, aleft, aright);  :}
//;

//SIF ::= IF PAR1 EXPRESION:a PAR2 LLAVE1 INSTRUCCIONES:b LLAVE2  {:   RESULT = new If(a, b, aleft, aright);   :}
//;

//TIPOS ::= INT       {:   RESULT=new Tipo(tipoDato.ENTERO);   :}
//        | DOUBLE    {:   RESULT=new Tipo(tipoDato.DECIMAL);   :}
//        | STRING    {:   RESULT=new Tipo(tipoDato.CADENA);   :}
//        | BOOL      {:   RESULT=new Tipo(tipoDato.BOOLEANO);   :}
//;

EXPRESION ::= MINUS EXPRESION:a             {:   RESULT = new Arithmetic(a, ArithmeticOperands.NEG, aleft, aright);   :} %prec UNIT_MINUS
            | EXPRESION:a ASTERISK EXPRESION:b{:   RESULT = new Arithmetic(a, b, ArithmeticOperands.MUL, aleft, aright);   :}
            | EXPRESION:a SLASH EXPRESION:b   {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.DIV, aleft, aright);   :}
            | EXPRESION:a DOUBLEASTERISK EXPRESION:b{:   RESULT = new Arithmetic(a, b, ArithmeticOperands.POW, aleft, aright);   :}
            | EXPRESION:a MODULO EXPRESION:b  {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.MOD, aleft, aright);   :}
            | EXPRESION:a MINUS EXPRESION:b  {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.SUB, aleft, aright);   :}
            | EXPRESION:a PLUS EXPRESION:b   {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.SUM, aleft, aright);   :}
//            | EXPRESION:a IGUAL IGUAL EXPRESION:b {:    RESULT = new Relacionales(a, b, OperadoresRelacionales.EQUALS, aleft, aright);    :}%prec EQUALS
            | INTEGER:a      {:   RESULT = new Primitive(Types.INTEGER,Integer.parseInt(a),  aleft, aright );   :}
            | DECIMAL:a     {:   RESULT = new Primitive(Types.DOUBLE,new Double(a),  aleft, aright );   :}
            | STRING:a      {:   RESULT = new Primitive( Types.STRING,a, aleft, aright );   :}
            | CHAR:a        {:   RESULT = new Primitive(Types.CHARACTER, a.charAt(0), aleft, aright );   :}
            | OPENPAR EXPRESION:a CLOSEPAR     {:   RESULT = a;   :}
//            | TRUE:a        {:   RESULT = new Nativo(true,     new Tipo(tipoDato.BOOLEANO), aleft, aright );   :}
//            | FALSE:a       {:   RESULT = new Nativo(false, new Tipo(tipoDato.BOOLEANO), aleft, aright );    :}
//            | ID:a          {:   RESULT = new AccesoVar(a, aleft, aright);   :}
;