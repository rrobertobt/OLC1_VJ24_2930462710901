package edu.robertob.olc1.vj24.Analysis;


import java_cup.runtime.Symbol;
import java.util.LinkedList;
import java.util.HashMap;
import edu.robertob.olc1.vj24.Engine.Base.Instruction;
import edu.robertob.olc1.vj24.Engine.Structs.Types;
import edu.robertob.olc1.vj24.Engine.Structs.JCError;

import edu.robertob.olc1.vj24.Engine.Statements.Print;
import edu.robertob.olc1.vj24.Engine.Statements.Declaration;
import edu.robertob.olc1.vj24.Engine.Statements.SymbolAssignation;
import edu.robertob.olc1.vj24.Engine.Expressions.SymbolAccess;
import edu.robertob.olc1.vj24.Engine.Statements.StartWithInvoke;
import edu.robertob.olc1.vj24.Engine.Statements.MethodDeclaration;
import edu.robertob.olc1.vj24.Engine.Statements.ReturnIns;
import edu.robertob.olc1.vj24.Engine.Expressions.MethodCall;

import edu.robertob.olc1.vj24.Engine.Expressions.Primitive;
import edu.robertob.olc1.vj24.Engine.Statements.IfStatement;
import edu.robertob.olc1.vj24.Engine.Statements.WhileStatement;
import edu.robertob.olc1.vj24.Engine.Statements.DoWhileStatement;
import edu.robertob.olc1.vj24.Engine.Statements.ForStatement;
import edu.robertob.olc1.vj24.Engine.Statements.Break;
import edu.robertob.olc1.vj24.Engine.Statements.Continue;
import edu.robertob.olc1.vj24.Engine.Expressions.TypeCast;

import edu.robertob.olc1.vj24.Engine.Expressions.Arithmetic;
import edu.robertob.olc1.vj24.Engine.Expressions.Comparison;
import edu.robertob.olc1.vj24.Engine.Structs.ComparisonOperands;
import edu.robertob.olc1.vj24.Engine.Expressions.Logical;
import edu.robertob.olc1.vj24.Engine.Structs.LogicalOperands;

import edu.robertob.olc1.vj24.Engine.Structs.ArithmeticOperands;

parser code
{:
    JCLexer s;
    JCParser(JCLexer s){this.s = s;}

//    public LinkedList<Errores> listaErrores = new LinkedList<>();
    private LinkedList<JCError> errorList = new LinkedList<>();
    public LinkedList<JCError> getSyntaxErrorList(){
        return errorList;
    }

    public void syntax_error(Symbol s){
        errorList.add(new JCError("Sintaxis", "Error en la instruccion, componente: "+s.value, s.left, s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        errorList.add(new JCError("Sintaxis - FATAL", "Error en la instruccion, componente: "+s.value, s.left, s.right));
    }

:}

action code
{:
:}

terminal UNIT_MINUS;
terminal String STRING, ID, INTEGER, DECIMAL, CHAR;
terminal ENDLINE, PLUS, MINUS, EQUALS, OPENBRACE, CLOSEBRACE, ASTERISK, SLASH, MODULO, DOUBLEASTERISK, NEGATION, COLON;
terminal DOUBLEEQUALS, LESS, GREATER, LESSEQUAL, GREATEREQUAL, NOT_EQUALS;
terminal OPENPAR, CLOSEPAR;
terminal RW_PRINT, RW_INT, RW_DOUBLE, RW_STRING, RW_IF, RW_TRUE, RW_FALSE, RW_BOOL, RW_CHAR, RW_ELSE, RW_VOID;
terminal RW_CONST, RW_VAR, RW_WHILE, RW_BREAK, RW_CONTINUE, RW_DO, RW_FOR, RW_START_WITH, RW_RETURN;
terminal OR, AND, XOR;
terminal COMMA, OPENBRACKET, CLOSEBRACKET;

nonterminal LinkedList<Instruction> START, STATEMENTS;
nonterminal Instruction STATEMENT;
nonterminal Instruction IMPRESION, DECLARATION, ASSIGNATION;
nonterminal Instruction IF_STMT, WHILE_STMT, DO_WHILE_STMT, FOR_STMT, FOR_UPDATE;
nonterminal Types TYPES;
nonterminal Instruction EXPRESION;
nonterminal Instruction INCREMENT, DECREMENT, BREAK, CONTINUE, INCREMENT_NO_ENDLINE, DECREMENT_NO_ENDLINE;
nonterminal TYPE_CAST_OPERATOR;
nonterminal IfStatement.ConditionBlock ELSE_IF_BLOCK;
nonterminal LinkedList<IfStatement.ConditionBlock> ELSE_IF_BLOCKS;
nonterminal Instruction START_WITH_INVOKE;
nonterminal Instruction METHOD_DECLARATION;
nonterminal LinkedList<HashMap> METHOD_PARAMS_DECLARATION;
nonterminal Instruction METHOD_CALL;
nonterminal LinkedList<Instruction> CALL_ARGUMENTS;
nonterminal Instruction ARGUMENT;
nonterminal Instruction RETURN_STMT;

precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NEGATION;
precedence left DOUBLEEQUALS, LESS, GREATER, LESSEQUAL, GREATEREQUAL, NOT_EQUALS;
precedence left PLUS, MINUS;
precedence left ASTERISK, SLASH, MODULO;
precedence nonassoc DOUBLEASTERISK;
precedence right UNIT_MINUS;

start with START;

START ::= STATEMENTS:a      {:   RESULT = a;   :}
;

STATEMENTS ::= STATEMENTS:a STATEMENT:b     {: RESULT = a; RESULT.add(b); :}
                | STATEMENT:a                   {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

STATEMENT ::= IMPRESION: a        {:   RESULT=a;   :}
                | DECLARATION:a       {:   RESULT=a;   :}
                | ASSIGNATION:a        {:   RESULT=a;   :}
                | IF_STMT:a               {:   RESULT=a;   :}
                | INCREMENT:a           {:   RESULT=a;   :}
                | DECREMENT:a           {:   RESULT=a;   :}
                | WHILE_STMT:a       {:   RESULT=a;   :}
                | FOR_STMT:a             {:   RESULT=a;   :}
                | DO_WHILE_STMT:a   {:   RESULT=a;   :}
                | RETURN_STMT:a       {:   RESULT=a;   :}
                | BREAK:a                   {:   RESULT=a;   :}
                | CONTINUE:a               {:   RESULT=a;   :}
                | START_WITH_INVOKE:a {:   RESULT=a;   :}
                | METHOD_CALL:a ENDLINE {:   RESULT=a;   :}
                | METHOD_DECLARATION:a {:   RESULT=a;   :}
                | error:e ENDLINE       {: :}
;

START_WITH_INVOKE ::= RW_START_WITH ID:a OPENPAR CLOSEPAR ENDLINE {:   RESULT = new StartWithInvoke(a, aleft, aright);   :}
;

BREAK ::= RW_BREAK:a ENDLINE {:   RESULT = new Break(aleft, aright);   :}
;

CONTINUE ::= RW_CONTINUE:a ENDLINE {:   RESULT = new Continue(aleft, aright);   :}
;

IMPRESION ::= RW_PRINT OPENPAR EXPRESION:a CLOSEPAR ENDLINE      {:   RESULT = new Print(a, aleft, aright);   :}
;


DECLARATION ::= RW_CONST ID:a COLON TYPES:b EQUALS EXPRESION:c ENDLINE    {:   RESULT = new Declaration(a, b, c, true, aleft, aright);   :}
              | RW_CONST ID:a COLON TYPES:b ENDLINE    {:   RESULT = new Declaration(a, b, null, true,aleft, aright);   :}
              | RW_VAR ID:a COLON TYPES:b ENDLINE    {:   RESULT = new Declaration(a, b, null, false, aleft, aright);   :}
              | RW_VAR ID:a COLON TYPES:b EQUALS EXPRESION:c ENDLINE    {:   RESULT = new Declaration(a, b, c, false, aleft, aright);   :}
              | RW_CONST ID:a COLON TYPES:b EQUALS METHOD_CALL:c ENDLINE    {:   RESULT = new Declaration(a, b, c, true, aleft, aright);   :}
              | RW_VAR ID:a COLON TYPES:b EQUALS METHOD_CALL:c ENDLINE    {:   RESULT = new Declaration(a, b, c, false, aleft, aright);   :}
              ;

//public MethodDeclaration(Types type, String id, LinkedList<HashMap> params, LinkedList<Instruction> methodBody, int line, int column)
METHOD_DECLARATION ::= TYPES:a ID:b OPENPAR CLOSEPAR OPENBRACE STATEMENTS:c CLOSEBRACE {:   RESULT = new MethodDeclaration(a, b, new LinkedList<HashMap>(), c, aleft, aright);   :}
                    | TYPES:a ID:b OPENPAR METHOD_PARAMS_DECLARATION:c CLOSEPAR OPENBRACE STATEMENTS:d CLOSEBRACE {:   RESULT = new MethodDeclaration(a, b, c, d, aleft, aright);   :}
              ;

METHOD_PARAMS_DECLARATION ::= METHOD_PARAMS_DECLARATION:a COMMA ID:c COLON TYPES:b {:
    RESULT = a;
    HashMap<String, Object> singleParam = new HashMap<>();
    singleParam.put("type", b);
    singleParam.put("id", c);
    RESULT.add(singleParam);
    :}

    |  ID:b COLON TYPES:a {:
        RESULT = new LinkedList<HashMap>();
        HashMap<String, Object> singleParam = new HashMap<>();
        singleParam.put("type", a);
        singleParam.put("id", b);
        RESULT.add(singleParam);
    :}
    ;

CALL_ARGUMENTS ::= CALL_ARGUMENTS:a COMMA ARGUMENT:b {: RESULT = a; a.add(b); :}
            | ARGUMENT:a {: RESULT = new LinkedList<>(); RESULT.add(a); :}
            ;

ARGUMENT ::= EXPRESION:a {: RESULT = a; :}
            | METHOD_CALL:a {: RESULT = a; :}
            ;

METHOD_CALL ::= ID:a OPENPAR CLOSEPAR {:  RESULT = new MethodCall(a, new LinkedList<>(), aleft, aright);   :}
            | ID:a OPENPAR CALL_ARGUMENTS:b CLOSEPAR {:  RESULT = new MethodCall(a, b, aleft, aright);   :}
            ;

RETURN_STMT ::= RW_RETURN EXPRESION:a ENDLINE {:   RESULT = new ReturnIns(a, aleft, aright);   :}
            | RW_RETURN:a ENDLINE {:   RESULT = new ReturnIns(null, aleft, aright);   :}
            | RW_RETURN METHOD_CALL:a ENDLINE {:   RESULT = new ReturnIns(a, aleft, aright);   :}
;


TYPE_CAST_OPERATOR ::= OPENPAR TYPES:type CLOSEPAR {:   RESULT = type; :}
;

ASSIGNATION ::= ID:a EQUALS EXPRESION:b ENDLINE  {:   RESULT=new SymbolAssignation(a, b, aleft, aright);  :}
            ;




IF_STMT ::=
 // if (){...}
 RW_IF OPENPAR EXPRESION:a CLOSEPAR OPENBRACE STATEMENTS:b CLOSEBRACE {:
               RESULT = new IfStatement(IfStatement.buildConditionBlockList(a, b, new LinkedList<IfStatement.ConditionBlock>()), aleft, aright);
           :}
// if (){...} else if (){...} else if (){...}
| RW_IF OPENPAR EXPRESION:a CLOSEPAR OPENBRACE STATEMENTS:b CLOSEBRACE ELSE_IF_BLOCKS:c {: RESULT = new IfStatement(IfStatement.buildConditionBlockList(a, b, c), aleft, aright); :}
//        | RW_IF OPENPAR EXPRESION:a CLOSEPAR OPENBRACE STATEMENTS:b CLOSEBRACE RW_ELSE OPENBRACE STATEMENTS:c CLOSEBRACE {:   RESULT = new IfStatement(a, b, c, aleft, aright);   :}
// if (){...} else if (){...} else if (){...} else {...}
| RW_IF OPENPAR EXPRESION:a CLOSEPAR OPENBRACE STATEMENTS:b CLOSEBRACE ELSE_IF_BLOCKS:c RW_ELSE OPENBRACE STATEMENTS:d CLOSEBRACE {:
    RESULT = new IfStatement(IfStatement.buildConditionBlockList(a, b, c), d, aleft, aright);
:}
// only if (){...} else {...}
| RW_IF OPENPAR EXPRESION:a CLOSEPAR OPENBRACE STATEMENTS:b CLOSEBRACE RW_ELSE OPENBRACE STATEMENTS:c CLOSEBRACE {:
    RESULT = new IfStatement(IfStatement.buildConditionBlockList(a, b, new LinkedList<IfStatement.ConditionBlock>()), c, aleft, aright);
:}
        ;

ELSE_IF_BLOCK ::= RW_ELSE RW_IF OPENPAR EXPRESION:a CLOSEPAR OPENBRACE STATEMENTS:b CLOSEBRACE {: RESULT = new IfStatement.ConditionBlock(a, b); :}
        ;

ELSE_IF_BLOCKS ::= ELSE_IF_BLOCKS:a ELSE_IF_BLOCK:e {: RESULT = a; a.add(e); :}
        | ELSE_IF_BLOCK:e {: RESULT = new LinkedList<>(); RESULT.add(e); :}
        ;

WHILE_STMT ::= RW_WHILE OPENPAR EXPRESION:a CLOSEPAR OPENBRACE STATEMENTS:b CLOSEBRACE {:   RESULT = new WhileStatement(a, b, aleft, aright);   :}
        ;

DO_WHILE_STMT ::= RW_DO OPENBRACE STATEMENTS:a CLOSEBRACE RW_WHILE OPENPAR EXPRESION:b CLOSEPAR {:   RESULT = new DoWhileStatement(b, a, aleft, aright);   :}
        | RW_DO OPENBRACE STATEMENTS:a CLOSEBRACE RW_WHILE OPENPAR EXPRESION:b CLOSEPAR ENDLINE {:   RESULT = new DoWhileStatement(b, a, aleft, aright);   :}
        ;

FOR_STMT ::= RW_FOR OPENPAR ASSIGNATION:a EXPRESION:b ENDLINE FOR_UPDATE:c CLOSEPAR OPENBRACE STATEMENTS:d CLOSEBRACE {:   RESULT = new ForStatement(a, b, c, d, aleft, aright);   :}
        ;

FOR_UPDATE ::= ID:a EQUALS EXPRESION:b {: RESULT = new SymbolAssignation(a, b, aleft, aright); :}
        | INCREMENT_NO_ENDLINE:a {: RESULT = a; :}
        | DECREMENT_NO_ENDLINE:a {: RESULT = a; :}
        ;

INCREMENT_NO_ENDLINE ::= ID:a PLUS PLUS {:   RESULT = new SymbolAssignation(a, new Arithmetic(new SymbolAccess(a, aleft, aright),new Primitive(Types.INTEGER, 1, aleft, aright),ArithmeticOperands.SUM, aleft, aright), aleft, aright);   :}
;
DECREMENT_NO_ENDLINE ::= ID:a MINUS MINUS {:   RESULT = new SymbolAssignation(a, new Arithmetic(new SymbolAccess(a, aleft, aright), new Primitive(Types.INTEGER, 1, aleft, aright), ArithmeticOperands.SUB, aleft, aright), aleft, aright);   :}
;

INCREMENT ::= ID:a PLUS PLUS ENDLINE {:   RESULT = new SymbolAssignation(a, new Arithmetic(new SymbolAccess(a, aleft, aright),new Primitive(Types.INTEGER, 1, aleft, aright),ArithmeticOperands.SUM, aleft, aright), aleft, aright);   :};
DECREMENT ::= ID:a MINUS MINUS ENDLINE {:   RESULT = new SymbolAssignation(a, new Arithmetic(new SymbolAccess(a, aleft, aright), new Primitive(Types.INTEGER, 1, aleft, aright), ArithmeticOperands.SUB, aleft, aright), aleft, aright);   :};


TYPES ::= RW_INT       {:   RESULT=Types.INTEGER;   :}
        | RW_DOUBLE    {:   RESULT=Types.DOUBLE;   :}
        | RW_STRING    {:   RESULT=Types.STRING;   :}
        | RW_BOOL      {:   RESULT=Types.BOOLEAN;   :}
        | RW_CHAR      {:   RESULT=Types.CHARACTER;   :}
        | RW_VOID      {:   RESULT=Types.VOID;   :}
        ;

EXPRESION ::=
            OPENPAR TYPES:a CLOSEPAR EXPRESION:b {:   RESULT = new TypeCast(b, a, aleft, aright);   :}
            | MINUS EXPRESION:a             {:   RESULT = new Arithmetic(a, ArithmeticOperands.NEG, aleft, aright);   :} %prec UNIT_MINUS
            | EXPRESION:a ASTERISK EXPRESION:b{:   RESULT = new Arithmetic(a, b, ArithmeticOperands.MUL, aleft, aright);   :}
            | EXPRESION:a SLASH EXPRESION:b   {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.DIV, aleft, aright);   :}
            | EXPRESION:a DOUBLEASTERISK EXPRESION:b{:   RESULT = new Arithmetic(a, b, ArithmeticOperands.POW, aleft, aright);   :}
            | EXPRESION:a MODULO EXPRESION:b  {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.MOD, aleft, aright);   :}
            | EXPRESION:a MINUS EXPRESION:b  {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.SUB, aleft, aright);   :}
            | EXPRESION:a PLUS EXPRESION:b   {:   RESULT = new Arithmetic(a, b, ArithmeticOperands.SUM, aleft, aright);   :}
            | EXPRESION:a DOUBLEEQUALS EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.EQUALS, aleft, aright);    :} %prec DOUBLEEQUALS
            | EXPRESION:a NOT_EQUALS EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.NOT_EQUALS, aleft, aright);    :}
            | EXPRESION:a LESS EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.LESS_THAN, aleft, aright);    :} %prec LESS
            | EXPRESION:a LESSEQUAL EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.LESS_THAN_OR_EQUALS, aleft, aright);    :} %prec LESSEQUAL
            | EXPRESION:a GREATER EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.GREATER_THAN, aleft, aright);    :} %prec GREATER
            | EXPRESION:a GREATEREQUAL EXPRESION:b {:    RESULT = new Comparison(a, b, ComparisonOperands.GREATER_THAN_OR_EQUALS, aleft, aright);    :} %prec GREATEREQUAL
            | NEGATION EXPRESION:a {:    RESULT = new Logical(a, LogicalOperands.NOT, aleft, aright);    :} %prec NEGATION
            | EXPRESION:a OR EXPRESION:b {:    RESULT = new Logical(a, b, LogicalOperands.OR, aleft, aright);    :}%prec OR
            | EXPRESION:a AND EXPRESION:b {:    RESULT = new Logical(a, b, LogicalOperands.AND, aleft, aright);    :}%prec AND
            | EXPRESION:a XOR EXPRESION:b {:    RESULT = new Logical(a, b, LogicalOperands.XOR, aleft, aright);    :}%prec XOR
            | INTEGER:a      {:   RESULT = new Primitive(Types.INTEGER,Integer.parseInt(a),  aleft, aright );   :}
            | DECIMAL:a     {:   RESULT = new Primitive(Types.DOUBLE,new Double(a),  aleft, aright );   :}
            | STRING:a      {:   RESULT = new Primitive( Types.STRING,a, aleft, aright );   :}
            | CHAR:a        {:   RESULT = new Primitive(Types.CHARACTER, a.charAt(0), aleft, aright );   :}
            | RW_TRUE:a     {:   RESULT = new Primitive(Types.BOOLEAN, true, aleft, aright );   :}
            | RW_FALSE:a    {:   RESULT = new Primitive(Types.BOOLEAN, false, aleft, aright );   :}
            | ID:a          {:   RESULT = new SymbolAccess(a, aleft, aright);   :}
            | OPENPAR EXPRESION:a CLOSEPAR     {:   RESULT = a;   :}
;